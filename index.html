YPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Untitled</title>
    

  </head>
    
  <body>
  <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Subway Car Racer Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background: #2c3e50; font-family: sans-serif; touch-action: none; }
        canvas { display: block; background: linear-gradient(#87CEEB, #2c3e50); }
        #ui {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: white; font-size: 22px; font-weight: bold; pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; cursor: pointer;
            z-index: 10;
        }
        .btn { background: #e74c3c; padding: 15px 30px; border-radius: 10px; margin-top: 15px; font-size: 20px; font-weight: bold; border: 2px solid white; }
    </style>
</head>
<body>

    <div id="ui">Score: 0 | Coins: 0</div>
    
    <div id="overlay" onclick="startGame()">
        <h1>CAR SURFER</h1>
        <p>Use ARROW KEYS or CLICK Left/Right</p>
        <div class="btn">CLICK TO START</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const overlay = document.getElementById('overlay');

    let w, h, laneW;
    let gameActive = false;
    let score = 0, coins = 0, speed = 6;
    let player = { lane: 1, x: 0, jumpY: 0, vY: 0, jumping: false };
    let obstacles = [];
    let items = [];

    function init() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        laneW = Math.min(w / 3.5, 130);
        player.x = w / 2;
    }

    window.addEventListener('resize', init);
    init();

    // INPUT HANDLING - Keyboard Fixed
    window.addEventListener('keydown', (e) => {
        if (!gameActive) {
            if (e.key === "Enter" || e.code === "Space") startGame();
            return;
        }
        
        // Prevent page scrolling with arrows
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) {
            e.preventDefault();
        }

        if (e.key === 'ArrowLeft' && player.lane > 0) player.lane--;
        if (e.key === 'ArrowRight' && player.lane < 2) player.lane++;
        if ((e.key === 'ArrowUp' || e.code === 'Space') && !player.jumping) {
            player.jumping = true;
            player.vY = 16;
        }
    });

    // Mouse/Touch controls
    window.addEventListener('mousedown', (e) => {
        if (!gameActive) return;
        const clickX = e.clientX;
        if (clickX < w * 0.3) { if(player.lane > 0) player.lane--; }
        else if (clickX > w * 0.7) { if(player.lane < 2) player.lane++; }
        else if (!player.jumping) { player.jumping = true; player.vY = 16; }
    });

    function startGame() {
        window.focus(); // Force focus on window
        score = 0; coins = 0; speed = 6;
        obstacles = []; items = [];
        player.lane = 1; gameActive = true;
        overlay.style.display = 'none';
        animate();
    }

    function spawn() {
        if (!gameActive) return;
        let lane = Math.floor(Math.random() * 3);
        if (Math.random() < 0.04) obstacles.push({ lane, z: h });
        if (Math.random() < 0.06) items.push({ lane, z: h });
    }

    function update() {
        score++;
        if (score % 400 === 0) speed += 0.4;
        let targetX = (w / 2 - laneW) + (player.lane * laneW);
        player.x += (targetX - player.x) * 0.2; // Sharper movement

        if (player.jumping) {
            player.jumpY += player.vY;
            player.vY -= 0.8;
            if (player.jumpY <= 0) { player.jumpY = 0; player.jumping = false; }
        }

        [obstacles, items].forEach((list, isCoin) => {
            for (let i = list.length - 1; i >= 0; i--) {
                list[i].z -= speed;
                if (list[i].z < 160 && list[i].z > 60 && player.lane === list[i].lane) {
                    if (isCoin === 1) { coins++; list.splice(i, 1); }
                    else if (player.jumpY < 45) {
                        gameActive = false;
                        overlay.style.display = 'flex';
                        overlay.innerHTML = `<h1>CRASHED!</h1><p>Score: ${Math.floor(score/10)} | Coins: ${coins}</p><div class="btn">RESTART (Click or Enter)</div>`;
                    }
                }
                if (list[i] && list[i].z < -100) list.splice(i, 1);
            }
        });

        if (Math.random() < 0.05) spawn();
        ui.innerText = `Score: ${Math.floor(score/10)} | Coins: ${coins}`;
    }

    function drawCar(x, y, color, isPlayer) {
        let carW = 45; let carH = 75;
        ctx.fillStyle = color;
        ctx.fillRect(x - carW/2, y - carH, carW, carH); // Body
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(x - carW/2 + 5, y - carH + 15, carW - 10, 35); // Glass area
        ctx.fillStyle = '#111';
        ctx.fillRect(x - carW/2 - 4, y - carH + 10, 5, 15); // Wheels
        ctx.fillRect(x + carW/2 - 1, y - carH + 10, 5, 15);
        ctx.fillRect(x - carW/2 - 4, y - 25, 5, 15);
        ctx.fillRect(x + carW/2 - 1, y - 25, 5, 15);
        
        ctx.fillStyle = isPlayer ? 'yellow' : 'red';
        ctx.fillRect(x - carW/2 + 5, isPlayer ? y - carH : y - 5, 10, 5); // Lights
        ctx.fillRect(x + carW/2 - 15, isPlayer ? y - carH : y - 5, 10, 5);
    }

    function draw() {
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#34495e'; // Road
        ctx.fillRect(w/2 - laneW*1.5, 0, laneW*3, h);
        
        ctx.strokeStyle = 'white'; ctx.setLineDash([30, 30]);
        for(let i=1; i<3; i++) {
            ctx.beginPath();
            ctx.moveTo(w/2 - laneW*1.5 + i*laneW, 0);
            ctx.lineTo(w/2 - laneW*1.5 + i*laneW, h);
            ctx.stroke();
        }

        items.forEach(c => { // Coins
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath(); ctx.arc((w/2 - laneW) + (c.lane * laneW), h - c.z + 20, 15, 0, Math.PI*2); ctx.fill();
        });

        drawCar(player.x, h - 100 - player.jumpY, '#2ecc71', true); // Player
        obstacles.forEach(o => drawCar((w/2 - laneW) + (o.lane * laneW), h - o.z, '#e74c3c', false)); // Enemie
    }

    function animate() {
        if (!gameActive) return;
        update();
        draw();
        requestAnimationFrame(animate);
    }
</script>
</body>
</html>
    
  </body>
  
</html>
